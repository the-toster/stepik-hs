{-
При вычислении каких из перечисленных ниже функций
использование seq предотвратит
нарастание количества невычисленных редексов
при увеличении значения первого аргумента:
-}

foo 0 x = x
foo n x = let x' = foo (n - 1) (x + 1)
          in x' `seq` x'
{-
 вижу тут рекурсивный вызов, глубина напрямую зависит от первого аргумента,
 рекурсивный вызов подается как первый аргумент в seq => действительно сокращает кол-во tunk-ов / редексов - это не верно
 в первый аргумент должно попадать что-то типа ф-ции переданной в свертку, тогда оно будет сокращать кол-во отложенных вычислений
-}

bar 0 f = f
bar x f = let f' = \a -> f (x + a)
              x' = x - 1
         in f' `seq` x' `seq` bar x' f'
{-
расставим скобки, в соответствии с :i seq, infixr 0 `seq`
    f' `seq` (x' `seq` (bar x' f'))
т.к. f' уже в WHNF, первый seq ничего не вычисляет, рассмотрим оставшееся выражение
x' `seq` (bar x' f')
x' вычисляется и используется в оставшемся выражении. Но он участвует в паттерн матчинге, значит и так бы вычислился.
Т.е. seq не влияет на кол-во редексов
-}

baz 0 (x, y) = x + y
baz n (x, y) = let x' = x + 1
                   y' = y - 1
                   p  = (x', y')
                   n' = n - 1
               in p `seq` n' `seq` baz n' p

{-
по совету преподавателя, данному в комментариях, надо попробовать вычислить правое выражение без seq.
baz 10 (1, 2)
~> baz (n - 1) (x', y')
~> baz (10 - 1) (x', y')
~> baz (9 - 1) (x', y')
n' вычисляется для паттерн матчинга, второй аргумент остается и порождает thunks

Но, использование p seq не вычислит эти thunks, т.к. второй аргумент - и так в слабой нормальной форме.
Следовательно, seq не предотвращает накопления thunks
-}


quux 0 (x, y) = x + y
quux n (x, y) = let x' = x + 1
                    y' = y - 1
                    p  = (x', y')
                    n' = n - 1
                in  x' `seq` y' `seq` n' `seq` quux n' p
{-
x' `seq` (y' `seq` (n' `seq` (quux n' p)))
тут без seq порядок редукции будет такой:
quux 3 (2, 1)
~> quux (2) (x', y')
~> quux (1) (x', y')
~> quux (0) (x', y')
~> x + y
первый аргумент вычисляется энергично для паттерн матчинга.
(x', y') - на каждом шаге будут добавляться, хотя и выкинуться в конце

с seq, x' и y' вычисляться заранее, и пара (x', y') уже не будет содержать thunks

т.е. в данном случае применение seq предотвратит нарастание редексов при росте первого аргумента.
-}
