{-
Пусть есть список положительных достоинств монет coins, отсортированный по возрастанию.
Воспользовавшись механизмом генераторов списков, напишите функцию change,
которая разбивает переданную ей положительную сумму денег на монеты достоинств из списка coins
всеми возможными способами.

Например, если coins = [2, 3, 7]:
GHCi> change 7
[[2,2,3],[2,3,2],[3,2,2],[7]]

Примечание. Порядок монет в каждом разбиении имеет значение, то есть наборы [2,2,3] и [2,3,2] — различаются.
Список coins определять не надо.
-}

{-# LANGUAGE NoMonomorphismRestriction #-}

change :: (Ord a, Num a) => a -> [[a]]
change s = [ x:y | x <- coins, y <- if s > x then change (s - x) else [[]], sum (x:y) == s]
{-
я почему-то решил что change 0 должен возвращать пустой список. На самом деле этого условия нет,
т.к. аргумент положительный, т.е. вместо if внутри генератора, можно было бы сделать уравнение
для нуля с ответом [[]]
-}

coins = [2, 3, 7]
test = change 7 == [[2,2,3],[2,3,2],[3,2,2],[7]]

